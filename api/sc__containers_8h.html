<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>p4est: sc/src/sc_containers.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">p4est
   &#160;<span id="projectnumber">0.3.5.274-55f6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_66577d727e7ebadc2d74b76f071e483e.html">sc</a></li><li class="navelem"><a class="el" href="dir_3f4075f02b3c7531c5bb57031bce0b87.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sc_containers.h File Reference<div class="ingroups"><a class="el" href="group__containers.html">containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines lists, arrays, hash tables, etc.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sc_obstack.h&gt;</code><br/>
</div>
<p><a href="sc__containers_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__array__t.html">sc_array_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sc_array object provides a large array of equal-size elements.  <a href="structsc__array__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sc_mempool object provides a large pool of equal-size elements.  <a href="structsc__mempool__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__link__t.html">sc_link_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sc_link structure is one link of a linked list.  <a href="structsc__link__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__list__t.html">sc_list_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sc_list object provides a linked list.  <a href="structsc__list__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__hash__t.html">sc_hash_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sc_hash implements a hash table.  <a href="structsc__hash__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__hash__array__data__t.html">sc_hash_array_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sc_hash_array implements an array backed up by a hash table.  <a href="structsc__hash__array__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sc_recycle_array object provides an array of slots that can be reused.  <a href="structsc__recycle__array__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab07c2062a328d6072fa398dcf34df750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07c2062a328d6072fa398dcf34df750"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sc_hash_rot</b>(x, k)&#160;&#160;&#160;(((x) &lt;&lt; (k)) | ((x) &gt;&gt; (32 - (k))))</td></tr>
<tr class="separator:ab07c2062a328d6072fa398dcf34df750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b111eda1aeb1c0c756c59d001a07caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>sc_hash_mix</b>(a, b, c)</td></tr>
<tr class="separator:a9b111eda1aeb1c0c756c59d001a07caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fd16d6e7d37a678e3e764f68893541"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>sc_hash_final</b>(a, b, c)</td></tr>
<tr class="separator:a15fd16d6e7d37a678e3e764f68893541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e37c27d608aabb0db95b28ccc27a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9e37c27d608aabb0db95b28ccc27a8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ad9e37c27d608aabb0db95b28ccc27a8d">SC_ARRAY_IS_OWNER</a>(a)&#160;&#160;&#160;((a)-&gt;byte_alloc &gt;= 0)</td></tr>
<tr class="memdesc:ad9e37c27d608aabb0db95b28ccc27a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">test whether the <a class="el" href="structsc__array__t.html" title="The sc_array object provides a large array of equal-size elements. ">sc_array_t</a> owns its <em>array</em> <br/></td></tr>
<tr class="separator:ad9e37c27d608aabb0db95b28ccc27a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94de2c6227fdb03f497aa2524257003"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ae94de2c6227fdb03f497aa2524257003">SC_ARRAY_BYTE_ALLOC</a>(a)</td></tr>
<tr class="memdesc:ae94de2c6227fdb03f497aa2524257003"><td class="mdescLeft">&#160;</td><td class="mdescRight">the allocated size of the array  <a href="#ae94de2c6227fdb03f497aa2524257003">More...</a><br/></td></tr>
<tr class="separator:ae94de2c6227fdb03f497aa2524257003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa6bfc43fa4a8b7626d8095725d4c7cfc"><td class="memItemLeft" align="right" valign="top">typedef unsigned(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa6bfc43fa4a8b7626d8095725d4c7cfc">sc_hash_function_t</a> )(const void *v, const void *u)</td></tr>
<tr class="memdesc:aa6bfc43fa4a8b7626d8095725d4c7cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute a hash value of an object.  <a href="#aa6bfc43fa4a8b7626d8095725d4c7cfc">More...</a><br/></td></tr>
<tr class="separator:aa6bfc43fa4a8b7626d8095725d4c7cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7e4c7164f43ab79e1e9d463c3c8584"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a3b7e4c7164f43ab79e1e9d463c3c8584">sc_equal_function_t</a> )(const void *v1, const void *v2, const void *u)</td></tr>
<tr class="memdesc:a3b7e4c7164f43ab79e1e9d463c3c8584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check equality of two objects.  <a href="#a3b7e4c7164f43ab79e1e9d463c3c8584">More...</a><br/></td></tr>
<tr class="separator:a3b7e4c7164f43ab79e1e9d463c3c8584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713a10d24f49429533235754a7a2fa69"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a713a10d24f49429533235754a7a2fa69">sc_hash_foreach_t</a> )(void **v, const void *u)</td></tr>
<tr class="memdesc:a713a10d24f49429533235754a7a2fa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call on every data item of a hash table.  <a href="#a713a10d24f49429533235754a7a2fa69">More...</a><br/></td></tr>
<tr class="separator:a713a10d24f49429533235754a7a2fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff78b02994e8b6d4da7e2c2b2db2a29"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a8ff78b02994e8b6d4da7e2c2b2db2a29">sc_array_type_t</a> )(<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t index, void *data)</td></tr>
<tr class="memdesc:a8ff78b02994e8b6d4da7e2c2b2db2a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine the enumerable type of an object in an array.  <a href="#a8ff78b02994e8b6d4da7e2c2b2db2a29">More...</a><br/></td></tr>
<tr class="separator:a8ff78b02994e8b6d4da7e2c2b2db2a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9c156f095e1050cd568689fa3615a7ed"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9c156f095e1050cd568689fa3615a7ed">sc_array_memory_used</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, int is_dynamic)</td></tr>
<tr class="memdesc:a9c156f095e1050cd568689fa3615a7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by an array.  <a href="#a9c156f095e1050cd568689fa3615a7ed">More...</a><br/></td></tr>
<tr class="separator:a9c156f095e1050cd568689fa3615a7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad880facede1dd567bd4da71fc8b46dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ad880facede1dd567bd4da71fc8b46dcd">sc_array_new</a> (size_t elem_size)</td></tr>
<tr class="memdesc:ad880facede1dd567bd4da71fc8b46dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new array structure with 0 elements.  <a href="#ad880facede1dd567bd4da71fc8b46dcd">More...</a><br/></td></tr>
<tr class="separator:ad880facede1dd567bd4da71fc8b46dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c87f129831c1e877429084dc97ebf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a27c87f129831c1e877429084dc97ebf8">sc_array_new_size</a> (size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a27c87f129831c1e877429084dc97ebf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new array structure with a given length (number of elements).  <a href="#a27c87f129831c1e877429084dc97ebf8">More...</a><br/></td></tr>
<tr class="separator:a27c87f129831c1e877429084dc97ebf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff8923e5659a46da89edfabb089d3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#acff8923e5659a46da89edfabb089d3f4">sc_array_new_view</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t offset, size_t length)</td></tr>
<tr class="memdesc:acff8923e5659a46da89edfabb089d3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new view of an existing <a class="el" href="structsc__array__t.html" title="The sc_array object provides a large array of equal-size elements. ">sc_array_t</a>.  <a href="#acff8923e5659a46da89edfabb089d3f4">More...</a><br/></td></tr>
<tr class="separator:acff8923e5659a46da89edfabb089d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ac4f8d8add15a6838cb0ec9c3319be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a45ac4f8d8add15a6838cb0ec9c3319be">sc_array_new_data</a> (void *base, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a45ac4f8d8add15a6838cb0ec9c3319be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new view of an existing plain C array.  <a href="#a45ac4f8d8add15a6838cb0ec9c3319be">More...</a><br/></td></tr>
<tr class="separator:a45ac4f8d8add15a6838cb0ec9c3319be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9538f758ce0adf6f61c7091dff1a693a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9538f758ce0adf6f61c7091dff1a693a">sc_array_destroy</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:a9538f758ce0adf6f61c7091dff1a693a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an array structure.  <a href="#a9538f758ce0adf6f61c7091dff1a693a">More...</a><br/></td></tr>
<tr class="separator:a9538f758ce0adf6f61c7091dff1a693a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253a39f46eda1adfc12871e3e52e2251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a253a39f46eda1adfc12871e3e52e2251">sc_array_init</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t elem_size)</td></tr>
<tr class="memdesc:a253a39f46eda1adfc12871e3e52e2251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) array structure.  <a href="#a253a39f46eda1adfc12871e3e52e2251">More...</a><br/></td></tr>
<tr class="separator:a253a39f46eda1adfc12871e3e52e2251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34588e4788f67b33bea0c99dc34e0473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a34588e4788f67b33bea0c99dc34e0473">sc_array_init_size</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a34588e4788f67b33bea0c99dc34e0473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) array structure and allocates a given number of elements.  <a href="#a34588e4788f67b33bea0c99dc34e0473">More...</a><br/></td></tr>
<tr class="separator:a34588e4788f67b33bea0c99dc34e0473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c755a6fdc7f4e3c490d9edb786cc5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa7c755a6fdc7f4e3c490d9edb786cc5d">sc_array_init_view</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *view, <a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t offset, size_t length)</td></tr>
<tr class="memdesc:aa7c755a6fdc7f4e3c490d9edb786cc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) view from existing <a class="el" href="structsc__array__t.html" title="The sc_array object provides a large array of equal-size elements. ">sc_array_t</a>.  <a href="#aa7c755a6fdc7f4e3c490d9edb786cc5d">More...</a><br/></td></tr>
<tr class="separator:aa7c755a6fdc7f4e3c490d9edb786cc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314b3cdbde02bc48303c9d60391286ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a314b3cdbde02bc48303c9d60391286ee">sc_array_init_data</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *view, void *base, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a314b3cdbde02bc48303c9d60391286ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) view from given plain C data.  <a href="#a314b3cdbde02bc48303c9d60391286ee">More...</a><br/></td></tr>
<tr class="separator:a314b3cdbde02bc48303c9d60391286ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df54afbedf05d9cf789c5ebb7599ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a6df54afbedf05d9cf789c5ebb7599ab4">sc_array_reset</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:a6df54afbedf05d9cf789c5ebb7599ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the array count to zero and frees all elements.  <a href="#a6df54afbedf05d9cf789c5ebb7599ab4">More...</a><br/></td></tr>
<tr class="separator:a6df54afbedf05d9cf789c5ebb7599ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6536ee67b1b02848dd529ffd1e3fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#acd6536ee67b1b02848dd529ffd1e3fec">sc_array_truncate</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:acd6536ee67b1b02848dd529ffd1e3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the array count to zero, but does not free elements.  <a href="#acd6536ee67b1b02848dd529ffd1e3fec">More...</a><br/></td></tr>
<tr class="separator:acd6536ee67b1b02848dd529ffd1e3fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584d8488f231972c68d44eb6239c9cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a584d8488f231972c68d44eb6239c9cd8">sc_array_resize</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t new_count)</td></tr>
<tr class="memdesc:a584d8488f231972c68d44eb6239c9cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element count to new_count.  <a href="#a584d8488f231972c68d44eb6239c9cd8">More...</a><br/></td></tr>
<tr class="separator:a584d8488f231972c68d44eb6239c9cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396352376b97fd861557f4b844ba0730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a396352376b97fd861557f4b844ba0730">sc_array_copy</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *dest, <a class="el" href="structsc__array__t.html">sc_array_t</a> *src)</td></tr>
<tr class="memdesc:a396352376b97fd861557f4b844ba0730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of an array into another.  <a href="#a396352376b97fd861557f4b844ba0730">More...</a><br/></td></tr>
<tr class="separator:a396352376b97fd861557f4b844ba0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750f7188a30c8c2756c77d70967b0caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a750f7188a30c8c2756c77d70967b0caf">sc_array_sort</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:a750f7188a30c8c2756c77d70967b0caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the array in ascending order wrt.  <a href="#a750f7188a30c8c2756c77d70967b0caf">More...</a><br/></td></tr>
<tr class="separator:a750f7188a30c8c2756c77d70967b0caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab930cdd0da30cd639b20a639990568e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab930cdd0da30cd639b20a639990568e1">sc_array_is_sorted</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:ab930cdd0da30cd639b20a639990568e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the array is sorted wrt.  <a href="#ab930cdd0da30cd639b20a639990568e1">More...</a><br/></td></tr>
<tr class="separator:ab930cdd0da30cd639b20a639990568e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc880037e9e90efb76648a5faa926e5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#adc880037e9e90efb76648a5faa926e5b">sc_array_is_equal</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, <a class="el" href="structsc__array__t.html">sc_array_t</a> *other)</td></tr>
<tr class="memdesc:adc880037e9e90efb76648a5faa926e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two arrays have equal size, count, and content.  <a href="#adc880037e9e90efb76648a5faa926e5b">More...</a><br/></td></tr>
<tr class="separator:adc880037e9e90efb76648a5faa926e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be396714f4ea39005cab1bc666666a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a7be396714f4ea39005cab1bc666666a6">sc_array_uniq</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:a7be396714f4ea39005cab1bc666666a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removed duplicate entries from a sorted array.  <a href="#a7be396714f4ea39005cab1bc666666a6">More...</a><br/></td></tr>
<tr class="separator:a7be396714f4ea39005cab1bc666666a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0759d2b44ed0aadb8c325f7bd5f5449"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa0759d2b44ed0aadb8c325f7bd5f5449">sc_array_bsearch</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, const void *key, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:aa0759d2b44ed0aadb8c325f7bd5f5449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search on an array.  <a href="#aa0759d2b44ed0aadb8c325f7bd5f5449">More...</a><br/></td></tr>
<tr class="separator:aa0759d2b44ed0aadb8c325f7bd5f5449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2072803b22a940c6e39498940768c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a4ef2072803b22a940c6e39498940768c">sc_array_split</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, <a class="el" href="structsc__array__t.html">sc_array_t</a> *offsets, size_t num_types, <a class="el" href="sc__containers_8h.html#a8ff78b02994e8b6d4da7e2c2b2db2a29">sc_array_type_t</a> type_fn, void *data)</td></tr>
<tr class="memdesc:a4ef2072803b22a940c6e39498940768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the offsets of groups of enumerable types in an array.  <a href="#a4ef2072803b22a940c6e39498940768c">More...</a><br/></td></tr>
<tr class="separator:a4ef2072803b22a940c6e39498940768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba51287db7e298935bd1fda5557fbacf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aba51287db7e298935bd1fda5557fbacf">sc_array_is_permutation</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:aba51287db7e298935bd1fda5557fbacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether <em>array</em> is an array of size_t's whose entries include every integer 0 &lt;= i &lt; array-&gt;elem_count.  <a href="#aba51287db7e298935bd1fda5557fbacf">More...</a><br/></td></tr>
<tr class="separator:aba51287db7e298935bd1fda5557fbacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05188345c402a4374c9e7ed4753e5c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a05188345c402a4374c9e7ed4753e5c8e">sc_array_permute</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, <a class="el" href="structsc__array__t.html">sc_array_t</a> *newindices, int keepperm)</td></tr>
<tr class="memdesc:a05188345c402a4374c9e7ed4753e5c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given permutation <em>newindices</em>, permute <em>array</em> in place.  <a href="#a05188345c402a4374c9e7ed4753e5c8e">More...</a><br/></td></tr>
<tr class="separator:a05188345c402a4374c9e7ed4753e5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfe6aa81985428a0576ec6b3f9cd506"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9dfe6aa81985428a0576ec6b3f9cd506">sc_array_checksum</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:a9dfe6aa81985428a0576ec6b3f9cd506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the adler32 checksum of array data (see zlib documentation).  <a href="#a9dfe6aa81985428a0576ec6b3f9cd506">More...</a><br/></td></tr>
<tr class="separator:a9dfe6aa81985428a0576ec6b3f9cd506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd0c405a3d83dfc251de2a390f43d88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aadd0c405a3d83dfc251de2a390f43d88">sc_array_pqueue_add</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, void *temp, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:aadd0c405a3d83dfc251de2a390f43d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to a priority queue.  <a href="#aadd0c405a3d83dfc251de2a390f43d88">More...</a><br/></td></tr>
<tr class="separator:aadd0c405a3d83dfc251de2a390f43d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ec1c3d19267b204a2f756fe428f196"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#af8ec1c3d19267b204a2f756fe428f196">sc_array_pqueue_pop</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, void *result, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:af8ec1c3d19267b204a2f756fe428f196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the smallest element from a priority queue.  <a href="#af8ec1c3d19267b204a2f756fe428f196">More...</a><br/></td></tr>
<tr class="separator:af8ec1c3d19267b204a2f756fe428f196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98803820bf36d496b238edfb7a423f9"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab98803820bf36d496b238edfb7a423f9">sc_array_index</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t iz)</td></tr>
<tr class="memdesc:ab98803820bf36d496b238edfb7a423f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array element.  <a href="#ab98803820bf36d496b238edfb7a423f9">More...</a><br/></td></tr>
<tr class="separator:ab98803820bf36d496b238edfb7a423f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3580da16cf5053ec505535d6226d781"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ac3580da16cf5053ec505535d6226d781">sc_array_index_int</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, int i)</td></tr>
<tr class="memdesc:ac3580da16cf5053ec505535d6226d781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array element indexed by a plain int.  <a href="#ac3580da16cf5053ec505535d6226d781">More...</a><br/></td></tr>
<tr class="separator:ac3580da16cf5053ec505535d6226d781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770cbf242a555a440049bddee206235c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a770cbf242a555a440049bddee206235c">sc_array_index_long</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, long l)</td></tr>
<tr class="memdesc:a770cbf242a555a440049bddee206235c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array element indexed by a plain long.  <a href="#a770cbf242a555a440049bddee206235c">More...</a><br/></td></tr>
<tr class="separator:a770cbf242a555a440049bddee206235c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdff3e930e20029d04b98ddbd832df4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a8cdff3e930e20029d04b98ddbd832df4">sc_array_index_ssize_t</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, ssize_t is)</td></tr>
<tr class="memdesc:a8cdff3e930e20029d04b98ddbd832df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array element indexed by a ssize_t.  <a href="#a8cdff3e930e20029d04b98ddbd832df4">More...</a><br/></td></tr>
<tr class="separator:a8cdff3e930e20029d04b98ddbd832df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c48798226f4299cdc633774bcfdab9"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa7c48798226f4299cdc633774bcfdab9">sc_array_index_int16</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, int16_t i16)</td></tr>
<tr class="memdesc:aa7c48798226f4299cdc633774bcfdab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array element indexed by a int16_t.  <a href="#aa7c48798226f4299cdc633774bcfdab9">More...</a><br/></td></tr>
<tr class="separator:aa7c48798226f4299cdc633774bcfdab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3a9fb0c7b081010e153d0c2301a8e9"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aab3a9fb0c7b081010e153d0c2301a8e9">sc_array_position</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, void *element)</td></tr>
<tr class="memdesc:aab3a9fb0c7b081010e153d0c2301a8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of an object in an array identified by a pointer.  <a href="#aab3a9fb0c7b081010e153d0c2301a8e9">More...</a><br/></td></tr>
<tr class="separator:aab3a9fb0c7b081010e153d0c2301a8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7319e610c0e71d953dfa62d0c15e46ed"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a7319e610c0e71d953dfa62d0c15e46ed">sc_array_pop</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:a7319e610c0e71d953dfa62d0c15e46ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from an array and return a pointer to it.  <a href="#a7319e610c0e71d953dfa62d0c15e46ed">More...</a><br/></td></tr>
<tr class="separator:a7319e610c0e71d953dfa62d0c15e46ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff497a0e6dc51efae7a2dec98fd6dc86"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aff497a0e6dc51efae7a2dec98fd6dc86">sc_array_push_count</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t add_count)</td></tr>
<tr class="memdesc:aff497a0e6dc51efae7a2dec98fd6dc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enlarge an array by a number of elements.  <a href="#aff497a0e6dc51efae7a2dec98fd6dc86">More...</a><br/></td></tr>
<tr class="separator:aff497a0e6dc51efae7a2dec98fd6dc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca8efc0ec4e5b8cc78c9a4a2dfecd6c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a2ca8efc0ec4e5b8cc78c9a4a2dfecd6c">sc_array_push</a> (<a class="el" href="structsc__array__t.html">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:a2ca8efc0ec4e5b8cc78c9a4a2dfecd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enlarge an array by one element.  <a href="#a2ca8efc0ec4e5b8cc78c9a4a2dfecd6c">More...</a><br/></td></tr>
<tr class="separator:a2ca8efc0ec4e5b8cc78c9a4a2dfecd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73235130bba53a9ed8b07ddfa27fadae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a73235130bba53a9ed8b07ddfa27fadae">sc_mempool_memory_used</a> (<a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:a73235130bba53a9ed8b07ddfa27fadae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by a memory pool.  <a href="#a73235130bba53a9ed8b07ddfa27fadae">More...</a><br/></td></tr>
<tr class="separator:a73235130bba53a9ed8b07ddfa27fadae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab416c24d85ffd174f0dd3ad89c4c1163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab416c24d85ffd174f0dd3ad89c4c1163">sc_mempool_new</a> (size_t elem_size)</td></tr>
<tr class="memdesc:ab416c24d85ffd174f0dd3ad89c4c1163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mempool structure.  <a href="#ab416c24d85ffd174f0dd3ad89c4c1163">More...</a><br/></td></tr>
<tr class="separator:ab416c24d85ffd174f0dd3ad89c4c1163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ecbb2b02cf93632c79c7307f5238ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a45ecbb2b02cf93632c79c7307f5238ba">sc_mempool_destroy</a> (<a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:a45ecbb2b02cf93632c79c7307f5238ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a mempool structure.  <a href="#a45ecbb2b02cf93632c79c7307f5238ba">More...</a><br/></td></tr>
<tr class="separator:a45ecbb2b02cf93632c79c7307f5238ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab483d01f1670c336d9cf76a8a2789d21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab483d01f1670c336d9cf76a8a2789d21"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab483d01f1670c336d9cf76a8a2789d21">sc_mempool_truncate</a> (<a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:ab483d01f1670c336d9cf76a8a2789d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates all previously returned pointers, resets count to 0. <br/></td></tr>
<tr class="separator:ab483d01f1670c336d9cf76a8a2789d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54946e5aa0c63bc895bee4756e7a10d6"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a54946e5aa0c63bc895bee4756e7a10d6">sc_mempool_alloc</a> (<a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:a54946e5aa0c63bc895bee4756e7a10d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a single element.  <a href="#a54946e5aa0c63bc895bee4756e7a10d6">More...</a><br/></td></tr>
<tr class="separator:a54946e5aa0c63bc895bee4756e7a10d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963b62dc73a1005533add75ad89308b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a963b62dc73a1005533add75ad89308b7">sc_mempool_free</a> (<a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *mempool, void *elem)</td></tr>
<tr class="memdesc:a963b62dc73a1005533add75ad89308b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a previously allocated element to the pool.  <a href="#a963b62dc73a1005533add75ad89308b7">More...</a><br/></td></tr>
<tr class="separator:a963b62dc73a1005533add75ad89308b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4ec6b2855dcb3125310f6ad2928ca1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#abc4ec6b2855dcb3125310f6ad2928ca1">sc_list_memory_used</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list, int is_dynamic)</td></tr>
<tr class="memdesc:abc4ec6b2855dcb3125310f6ad2928ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by a list.  <a href="#abc4ec6b2855dcb3125310f6ad2928ca1">More...</a><br/></td></tr>
<tr class="separator:abc4ec6b2855dcb3125310f6ad2928ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed388e36eb3088d911d68f995be3b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a16ed388e36eb3088d911d68f995be3b1">sc_list_new</a> (<a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *allocator)</td></tr>
<tr class="memdesc:a16ed388e36eb3088d911d68f995be3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a linked list structure.  <a href="#a16ed388e36eb3088d911d68f995be3b1">More...</a><br/></td></tr>
<tr class="separator:a16ed388e36eb3088d911d68f995be3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d366868c0011ee034b4e1b5d6f701f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab9d366868c0011ee034b4e1b5d6f701f">sc_list_destroy</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:ab9d366868c0011ee034b4e1b5d6f701f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a linked list structure in O(N).  <a href="#ab9d366868c0011ee034b4e1b5d6f701f">More...</a><br/></td></tr>
<tr class="separator:ab9d366868c0011ee034b4e1b5d6f701f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2345f4f800f46d60d612c6d9545758dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a2345f4f800f46d60d612c6d9545758dd">sc_list_init</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list, <a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *allocator)</td></tr>
<tr class="memdesc:a2345f4f800f46d60d612c6d9545758dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated list structure.  <a href="#a2345f4f800f46d60d612c6d9545758dd">More...</a><br/></td></tr>
<tr class="separator:a2345f4f800f46d60d612c6d9545758dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87b22d2b61f04d3c73d93e9218b97c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab87b22d2b61f04d3c73d93e9218b97c7">sc_list_reset</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:ab87b22d2b61f04d3c73d93e9218b97c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from a list in O(N).  <a href="#ab87b22d2b61f04d3c73d93e9218b97c7">More...</a><br/></td></tr>
<tr class="separator:ab87b22d2b61f04d3c73d93e9218b97c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5934247f1587a5376772ec2d035f812f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a5934247f1587a5376772ec2d035f812f">sc_list_unlink</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:a5934247f1587a5376772ec2d035f812f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unliks all list elements without returning them to the mempool.  <a href="#a5934247f1587a5376772ec2d035f812f">More...</a><br/></td></tr>
<tr class="separator:a5934247f1587a5376772ec2d035f812f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53f97c53f9ffd13e0361c46f30038c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd53f97c53f9ffd13e0361c46f30038c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sc_list_prepend</b> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list, void *data)</td></tr>
<tr class="separator:afd53f97c53f9ffd13e0361c46f30038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a656e413894e105e7b8682e353deee8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a656e413894e105e7b8682e353deee8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sc_list_append</b> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list, void *data)</td></tr>
<tr class="separator:a4a656e413894e105e7b8682e353deee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306aa840346179aaaab47cbd8c4f2e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a306aa840346179aaaab47cbd8c4f2e50">sc_list_insert</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list, <a class="el" href="structsc__link__t.html">sc_link_t</a> *pred, void *data)</td></tr>
<tr class="memdesc:a306aa840346179aaaab47cbd8c4f2e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element after a given position.  <a href="#a306aa840346179aaaab47cbd8c4f2e50">More...</a><br/></td></tr>
<tr class="separator:a306aa840346179aaaab47cbd8c4f2e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1dfcc941294ac2b6898db6b798938d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aaf1dfcc941294ac2b6898db6b798938d">sc_list_remove</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list, <a class="el" href="structsc__link__t.html">sc_link_t</a> *pred)</td></tr>
<tr class="memdesc:aaf1dfcc941294ac2b6898db6b798938d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element after a given position.  <a href="#aaf1dfcc941294ac2b6898db6b798938d">More...</a><br/></td></tr>
<tr class="separator:aaf1dfcc941294ac2b6898db6b798938d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcaa9043e79854360ab37bdc670e668"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#affcaa9043e79854360ab37bdc670e668">sc_list_pop</a> (<a class="el" href="structsc__list__t.html">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:affcaa9043e79854360ab37bdc670e668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the front of the list.  <a href="#affcaa9043e79854360ab37bdc670e668">More...</a><br/></td></tr>
<tr class="separator:affcaa9043e79854360ab37bdc670e668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef8c7f8057e0f36ea6f1c6f2ab6c571"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#afef8c7f8057e0f36ea6f1c6f2ab6c571">sc_hash_function_string</a> (const void *s, const void *u)</td></tr>
<tr class="memdesc:afef8c7f8057e0f36ea6f1c6f2ab6c571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value from a null-terminated string.  <a href="#afef8c7f8057e0f36ea6f1c6f2ab6c571">More...</a><br/></td></tr>
<tr class="separator:afef8c7f8057e0f36ea6f1c6f2ab6c571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61448f834b749daa38248ad391417e0a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a61448f834b749daa38248ad391417e0a">sc_hash_memory_used</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:a61448f834b749daa38248ad391417e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by a hash table.  <a href="#a61448f834b749daa38248ad391417e0a">More...</a><br/></td></tr>
<tr class="separator:a61448f834b749daa38248ad391417e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79301891a134c0765dd8770cd88545d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a79301891a134c0765dd8770cd88545d1">sc_hash_new</a> (<a class="el" href="sc__containers_8h.html#aa6bfc43fa4a8b7626d8095725d4c7cfc">sc_hash_function_t</a> hash_fn, <a class="el" href="sc__containers_8h.html#a3b7e4c7164f43ab79e1e9d463c3c8584">sc_equal_function_t</a> equal_fn, void *user_data, <a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *allocator)</td></tr>
<tr class="memdesc:a79301891a134c0765dd8770cd88545d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new hash table.  <a href="#a79301891a134c0765dd8770cd88545d1">More...</a><br/></td></tr>
<tr class="separator:a79301891a134c0765dd8770cd88545d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485f83fdfee14e4a14573f4efe7c108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a4485f83fdfee14e4a14573f4efe7c108">sc_hash_destroy</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:a4485f83fdfee14e4a14573f4efe7c108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a hash table.  <a href="#a4485f83fdfee14e4a14573f4efe7c108">More...</a><br/></td></tr>
<tr class="separator:a4485f83fdfee14e4a14573f4efe7c108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6018b3a4e5c51501d52094335bb85d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a6018b3a4e5c51501d52094335bb85d11">sc_hash_truncate</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:a6018b3a4e5c51501d52094335bb85d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all entries from a hash table in O(N).  <a href="#a6018b3a4e5c51501d52094335bb85d11">More...</a><br/></td></tr>
<tr class="separator:a6018b3a4e5c51501d52094335bb85d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2992a0fc01581345b413f460a4b7927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab2992a0fc01581345b413f460a4b7927">sc_hash_unlink</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:ab2992a0fc01581345b413f460a4b7927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink all hash elements without returning them to the mempool.  <a href="#ab2992a0fc01581345b413f460a4b7927">More...</a><br/></td></tr>
<tr class="separator:ab2992a0fc01581345b413f460a4b7927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fe8987fef58946b5327ea202cfb9c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab6fe8987fef58946b5327ea202cfb9c7">sc_hash_unlink_destroy</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:ab6fe8987fef58946b5327ea202cfb9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same effect as unlink and destroy, but in O(1).  <a href="#ab6fe8987fef58946b5327ea202cfb9c7">More...</a><br/></td></tr>
<tr class="separator:ab6fe8987fef58946b5327ea202cfb9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac491f058bd4a47555c203e94db47f37c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ac491f058bd4a47555c203e94db47f37c">sc_hash_lookup</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash, void *v, void ***found)</td></tr>
<tr class="memdesc:ac491f058bd4a47555c203e94db47f37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an object is contained in the hash table.  <a href="#ac491f058bd4a47555c203e94db47f37c">More...</a><br/></td></tr>
<tr class="separator:ac491f058bd4a47555c203e94db47f37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471ac510c147c97b396a980d7cfc6852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a471ac510c147c97b396a980d7cfc6852">sc_hash_insert_unique</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash, void *v, void ***found)</td></tr>
<tr class="memdesc:a471ac510c147c97b396a980d7cfc6852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into a hash table if it is not contained already.  <a href="#a471ac510c147c97b396a980d7cfc6852">More...</a><br/></td></tr>
<tr class="separator:a471ac510c147c97b396a980d7cfc6852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3368ef4a371e8128a96e159ea28c3c63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a3368ef4a371e8128a96e159ea28c3c63">sc_hash_remove</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash, void *v, void **found)</td></tr>
<tr class="memdesc:a3368ef4a371e8128a96e159ea28c3c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object from a hash table.  <a href="#a3368ef4a371e8128a96e159ea28c3c63">More...</a><br/></td></tr>
<tr class="separator:a3368ef4a371e8128a96e159ea28c3c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbe548fa780a3d3ce1a719075eb3d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#accbe548fa780a3d3ce1a719075eb3d5a">sc_hash_foreach</a> (<a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash, <a class="el" href="sc__containers_8h.html#a713a10d24f49429533235754a7a2fa69">sc_hash_foreach_t</a> fn)</td></tr>
<tr class="memdesc:accbe548fa780a3d3ce1a719075eb3d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a callback for every member of the hash table.  <a href="#accbe548fa780a3d3ce1a719075eb3d5a">More...</a><br/></td></tr>
<tr class="separator:accbe548fa780a3d3ce1a719075eb3d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b5d86966197595ae5ecd9471af8e05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1b5d86966197595ae5ecd9471af8e05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ae1b5d86966197595ae5ecd9471af8e05">sc_hash_print_statistics</a> (int package_id, int log_priority, <a class="el" href="structsc__hash__t.html">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:ae1b5d86966197595ae5ecd9471af8e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and print statistical information about the occupancy. <br/></td></tr>
<tr class="separator:ae1b5d86966197595ae5ecd9471af8e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e5cf0f7ea5b4a16e534a19fffa595"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a287e5cf0f7ea5b4a16e534a19fffa595">sc_hash_array_memory_used</a> (<a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *ha)</td></tr>
<tr class="memdesc:a287e5cf0f7ea5b4a16e534a19fffa595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by a hash array.  <a href="#a287e5cf0f7ea5b4a16e534a19fffa595">More...</a><br/></td></tr>
<tr class="separator:a287e5cf0f7ea5b4a16e534a19fffa595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa086b8ede8a18ebdcfb690d6bf73e86a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa086b8ede8a18ebdcfb690d6bf73e86a">sc_hash_array_new</a> (size_t elem_size, <a class="el" href="sc__containers_8h.html#aa6bfc43fa4a8b7626d8095725d4c7cfc">sc_hash_function_t</a> hash_fn, <a class="el" href="sc__containers_8h.html#a3b7e4c7164f43ab79e1e9d463c3c8584">sc_equal_function_t</a> equal_fn, void *user_data)</td></tr>
<tr class="memdesc:aa086b8ede8a18ebdcfb690d6bf73e86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new hash array.  <a href="#aa086b8ede8a18ebdcfb690d6bf73e86a">More...</a><br/></td></tr>
<tr class="separator:aa086b8ede8a18ebdcfb690d6bf73e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe72e9f693035fffc01e42dbd1f52859"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe72e9f693035fffc01e42dbd1f52859"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#abe72e9f693035fffc01e42dbd1f52859">sc_hash_array_destroy</a> (<a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *hash_array)</td></tr>
<tr class="memdesc:abe72e9f693035fffc01e42dbd1f52859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a hash array. <br/></td></tr>
<tr class="separator:abe72e9f693035fffc01e42dbd1f52859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36fbe3c869bded837f9976c20ea7b95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac36fbe3c869bded837f9976c20ea7b95"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ac36fbe3c869bded837f9976c20ea7b95">sc_hash_array_is_valid</a> (<a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *hash_array)</td></tr>
<tr class="memdesc:ac36fbe3c869bded837f9976c20ea7b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the internal consistency of a hash array. <br/></td></tr>
<tr class="separator:ac36fbe3c869bded837f9976c20ea7b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8557bf638bc729901df79c86f05e04c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a8557bf638bc729901df79c86f05e04c4">sc_hash_array_truncate</a> (<a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *hash_array)</td></tr>
<tr class="memdesc:a8557bf638bc729901df79c86f05e04c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from the hash array.  <a href="#a8557bf638bc729901df79c86f05e04c4">More...</a><br/></td></tr>
<tr class="separator:a8557bf638bc729901df79c86f05e04c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1743a8aa716313f45e754b05f4066d07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a1743a8aa716313f45e754b05f4066d07">sc_hash_array_lookup</a> (<a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *hash_array, void *v, size_t *position)</td></tr>
<tr class="memdesc:a1743a8aa716313f45e754b05f4066d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an object is contained in a hash array.  <a href="#a1743a8aa716313f45e754b05f4066d07">More...</a><br/></td></tr>
<tr class="separator:a1743a8aa716313f45e754b05f4066d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc4c1933168da0ac3b075df053ceab3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a0cc4c1933168da0ac3b075df053ceab3">sc_hash_array_insert_unique</a> (<a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *hash_array, void *v, size_t *position)</td></tr>
<tr class="memdesc:a0cc4c1933168da0ac3b075df053ceab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into a hash array if it is not contained already.  <a href="#a0cc4c1933168da0ac3b075df053ceab3">More...</a><br/></td></tr>
<tr class="separator:a0cc4c1933168da0ac3b075df053ceab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5b81adba0e4c4c3c557dcf7613f36b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aaf5b81adba0e4c4c3c557dcf7613f36b">sc_hash_array_rip</a> (<a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *hash_array, <a class="el" href="structsc__array__t.html">sc_array_t</a> *rip)</td></tr>
<tr class="memdesc:aaf5b81adba0e4c4c3c557dcf7613f36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the array data from a hash array and destroy everything else.  <a href="#aaf5b81adba0e4c4c3c557dcf7613f36b">More...</a><br/></td></tr>
<tr class="separator:aaf5b81adba0e4c4c3c557dcf7613f36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f00fc29ceeed5ee0b0629aa36ec7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a953f00fc29ceeed5ee0b0629aa36ec7e">sc_recycle_array_init</a> (<a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *rec_array, size_t elem_size)</td></tr>
<tr class="memdesc:a953f00fc29ceeed5ee0b0629aa36ec7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a recycle array.  <a href="#a953f00fc29ceeed5ee0b0629aa36ec7e">More...</a><br/></td></tr>
<tr class="separator:a953f00fc29ceeed5ee0b0629aa36ec7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cade0e4211936ded04e2a2e7df9ca33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a2cade0e4211936ded04e2a2e7df9ca33">sc_recycle_array_reset</a> (<a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *rec_array)</td></tr>
<tr class="memdesc:a2cade0e4211936ded04e2a2e7df9ca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a recycle array.  <a href="#a2cade0e4211936ded04e2a2e7df9ca33">More...</a><br/></td></tr>
<tr class="separator:a2cade0e4211936ded04e2a2e7df9ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40dce6d559ee358c2bb469e64c379d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#adc40dce6d559ee358c2bb469e64c379d">sc_recycle_array_insert</a> (<a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *rec_array, size_t *position)</td></tr>
<tr class="memdesc:adc40dce6d559ee358c2bb469e64c379d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into the recycle array.  <a href="#adc40dce6d559ee358c2bb469e64c379d">More...</a><br/></td></tr>
<tr class="separator:adc40dce6d559ee358c2bb469e64c379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788e8444ddf769046c38afc05bfac38e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a788e8444ddf769046c38afc05bfac38e">sc_recycle_array_remove</a> (<a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *rec_array, size_t position)</td></tr>
<tr class="memdesc:a788e8444ddf769046c38afc05bfac38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object from the recycle array.  <a href="#a788e8444ddf769046c38afc05bfac38e">More...</a><br/></td></tr>
<tr class="separator:a788e8444ddf769046c38afc05bfac38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines lists, arrays, hash tables, etc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae94de2c6227fdb03f497aa2524257003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_ARRAY_BYTE_ALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((size_t) \</div>
<div class="line">         (<a class="code" href="sc__containers_8h.html#ad9e37c27d608aabb0db95b28ccc27a8d">SC_ARRAY_IS_OWNER</a> (a) ? (a)-&gt;byte_alloc : -((a)-&gt;byte_alloc + 1)))</div>
<div class="ttc" id="sc__containers_8h_html_ad9e37c27d608aabb0db95b28ccc27a8d"><div class="ttname"><a href="sc__containers_8h.html#ad9e37c27d608aabb0db95b28ccc27a8d">SC_ARRAY_IS_OWNER</a></div><div class="ttdeci">#define SC_ARRAY_IS_OWNER(a)</div><div class="ttdoc">test whether the sc_array_t owns its array </div><div class="ttdef"><b>Definition:</b> sc_containers.h:109</div></div>
</div><!-- fragment -->
<p>the allocated size of the array </p>

</div>
</div>
<a class="anchor" id="a15fd16d6e7d37a678e3e764f68893541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sc_hash_final</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((void)                            \</div>
<div class="line">                              (c ^= b, c -= sc_hash_rot(b,14),  \</div>
<div class="line">                               a ^= c, a -= sc_hash_rot(c,11),  \</div>
<div class="line">                               b ^= a, b -= sc_hash_rot(a,25),  \</div>
<div class="line">                               c ^= b, c -= sc_hash_rot(b,16),  \</div>
<div class="line">                               a ^= c, a -= sc_hash_rot(c, 4),  \</div>
<div class="line">                               b ^= a, b -= sc_hash_rot(a,14),  \</div>
<div class="line">                               c ^= b, c -= sc_hash_rot(b,24)))</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9b111eda1aeb1c0c756c59d001a07caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sc_hash_mix</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((void)                                      \</div>
<div class="line">                            (a -= c, a ^= sc_hash_rot(c, 4), c += b,    \</div>
<div class="line">                             b -= a, b ^= sc_hash_rot(a, 6), a += c,    \</div>
<div class="line">                             c -= b, c ^= sc_hash_rot(b, 8), b += a,    \</div>
<div class="line">                             a -= c, a ^= sc_hash_rot(c,16), c += b,    \</div>
<div class="line">                             b -= a, b ^= sc_hash_rot(a,19), a += c,    \</div>
<div class="line">                             c -= b, c ^= sc_hash_rot(b, 4), b += a))</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8ff78b02994e8b6d4da7e2c2b2db2a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* sc_array_type_t)(<a class="el" href="structsc__array__t.html">sc_array_t</a> *array, size_t index, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to determine the enumerable type of an object in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>Array containing the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The location of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b7e4c7164f43ab79e1e9d463c3c8584"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sc_equal_function_t)(const void *v1, const void *v2, const void *u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check equality of two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if *v1 is unequal *v2 and true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a713a10d24f49429533235754a7a2fa69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sc_hash_foreach_t)(void **v, const void *u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call on every data item of a hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The address of the pointer to the current object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the traversal should continue, false to stop. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6bfc43fa4a8b7626d8095725d4c7cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned(* sc_hash_function_t)(const void *v, const void *u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute a hash value of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to hash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an unsigned integer. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa0759d2b44ed0aadb8c325f7bd5f5449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sc_array_bsearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary search on an array. </p>
<p>The array must be sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>A sorted array to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>An element to be searched for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index into array for the item found, or -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dfe6aa81985428a0576ec6b3f9cd506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned sc_array_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the adler32 checksum of array data (see zlib documentation). </p>
<p>This is a faster checksum than crc32, and it works with zeros as data. </p>

</div>
</div>
<a class="anchor" id="a396352376b97fd861557f4b844ba0730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of an array into another. </p>
<p>Both arrays must have equal element sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Array (not a view) will be resized and get new data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Array used as source of new data, will not be changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9538f758ce0adf6f61c7091dff1a693a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an array structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab98803820bf36d496b238edfb7a423f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>needs to be in [0]..[elem_count-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3580da16cf5053ec505535d6226d781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_index_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an array element indexed by a plain int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>needs to be in [0]..[elem_count-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7c48798226f4299cdc633774bcfdab9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_index_int16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>i16</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an array element indexed by a int16_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>needs to be in [0]..[elem_count-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a770cbf242a555a440049bddee206235c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_index_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an array element indexed by a plain long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>needs to be in [0]..[elem_count-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cdff3e930e20029d04b98ddbd832df4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_index_ssize_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>is</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an array element indexed by a ssize_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>needs to be in [0]..[elem_count-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a253a39f46eda1adfc12871e3e52e2251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) array structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a314b3cdbde02bc48303c9d60391286ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) view from given plain C data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">view</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The data must not be moved while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>The length of the view in element units. The view cannot be resized to exceed this length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34588e4788f67b33bea0c99dc34e0473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) array structure and allocates a given number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>Number of initial array elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7c755a6fdc7f4e3c490d9edb786cc5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) view from existing <a class="el" href="structsc__array__t.html" title="The sc_array object provides a large array of equal-size elements. ">sc_array_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">view</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array must not be resized while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset of the viewed section in element units. This offset cannot be changed until the view is reset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the view in element units. The view cannot be resized to exceed this length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc880037e9e90efb76648a5faa926e5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_array_is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether two arrays have equal size, count, and content. </p>
<p>Either array may be a view. Both arrays will not be changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>One array to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>A second array to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if array and other are equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aba51287db7e298935bd1fda5557fbacf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_array_is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether <em>array</em> is an array of size_t's whose entries include every integer 0 &lt;= i &lt; array-&gt;elem_count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>An array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if array contains size_t elements whose entries include every integer 0 &lt;= i &lt; <em>array-&gt;elem_count</em>, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab930cdd0da30cd639b20a639990568e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_array_is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the array is sorted wrt. </p>
<p>the comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if array is sorted, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c156f095e1050cd568689fa3615a7ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_array_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_dynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_dynamic</td><td>True if created with sc_array_new, false if initialized with sc_array_init </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad880facede1dd567bd4da71fc8b46dcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__array__t.html">sc_array_t</a>* sc_array_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new array structure with 0 elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return an allocated array of zero length. </dd></dl>

</div>
</div>
<a class="anchor" id="a45ac4f8d8add15a6838cb0ec9c3319be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__array__t.html">sc_array_t</a>* sc_array_new_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new view of an existing plain C array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The data must not be moved while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>The length of the view in element units. The view cannot be resized to exceed this length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27c87f129831c1e877429084dc97ebf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__array__t.html">sc_array_t</a>* sc_array_new_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new array structure with a given length (number of elements). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>Initial number of array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return an allocated array with allocated but uninitialized elements. </dd></dl>

</div>
</div>
<a class="anchor" id="acff8923e5659a46da89edfabb089d3f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__array__t.html">sc_array_t</a>* sc_array_new_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new view of an existing <a class="el" href="structsc__array__t.html" title="The sc_array object provides a large array of equal-size elements. ">sc_array_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array must not be resized while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset of the viewed section in element units. This offset cannot be changed until the view is reset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the viewed section in element units. The view cannot be resized to exceed this length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05188345c402a4374c9e7ed4753e5c8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_permute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>newindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keepperm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given permutation <em>newindices</em>, permute <em>array</em> in place. </p>
<p>The data that on input is contained in <em>array</em>[i] will be contained in <em>array</em>[newindices[i]] on output. The entries of newindices will be altered unless <em>keepperm</em> is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>An array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newindices</td><td>Permutation array (see sc_array_is_permutation). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepperm</td><td>If true, <em>newindices</em> will be unchanged by the algorithm; if false, <em>newindices</em> will be the identity permutation on output, but the algorithm will only use O(1) space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7319e610c0e71d953dfa62d0c15e46ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element from an array and return a pointer to it. </p>
<p>This function is not allowed for views. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the removed object. Will be valid as long as no other function is called on this array. </dd></dl>

</div>
</div>
<a class="anchor" id="aab3a9fb0c7b081010e153d0c2301a8e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t sc_array_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index of an object in an array identified by a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>needs to be the address of an element in array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadd0c405a3d83dfc251de2a390f43d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_array_pqueue_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to a priority queue. </p>
<p>PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. The priority queue is implemented as a heap in ascending order. A heap is a binary tree where the children are not less than their parent. Assumes that elements [0]..[elem_count-2] form a valid heap. Then propagates [elem_count-1] upward by swapping if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>Pointer to unused allocated memory of elem_size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of swap operations. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the return value is zero for all elements in an array, the array is sorted linearly and unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="af8ec1c3d19267b204a2f756fe428f196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_array_pqueue_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the smallest element from a priority queue. </p>
<p>PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. This function assumes that the array forms a valid heap in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to unused allocated memory of elem_size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of swap operations. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function resizes the array to elem_count-1. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca8efc0ec4e5b8cc78c9a4a2dfecd6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enlarge an array by one element. </p>
<p>Grows the array if necessary. This function is not allowed for views. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the uninitialized newly added element. </dd></dl>

</div>
</div>
<a class="anchor" id="aff497a0e6dc51efae7a2dec98fd6dc86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_array_push_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>add_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enlarge an array by a number of elements. </p>
<p>Grows the array if necessary. This function is not allowed for views. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the uninitialized newly added elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a6df54afbedf05d9cf789c5ebb7599ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the array count to zero and frees all elements. </p>
<p>This function turns a view into a newly initialized array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling sc_array_init, then any array operations, then sc_array_reset is memory neutral. </dd></dl>

</div>
</div>
<a class="anchor" id="a584d8488f231972c68d44eb6239c9cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the element count to new_count. </p>
<p>If this a view, new_count cannot be greater than the elem_count of the view when it was created. The original offset of the view cannot be changed. If this is an array, reallocation takes place only occasionally, so this function is usually fast. </p>

</div>
</div>
<a class="anchor" id="a750f7188a30c8c2756c77d70967b0caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the array in ascending order wrt. </p>
<p>the comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array to sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ef2072803b22a940c6e39498940768c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a8ff78b02994e8b6d4da7e2c2b2db2a29">sc_array_type_t</a>&#160;</td>
          <td class="paramname"><em>type_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the offsets of groups of enumerable types in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>Array that is sorted in ascending order by type. If k indexes <em>array</em>, then 0 &lt;= <em>type_fn</em> (<em>array</em>, k, <em>data</em>) &lt; <em>num_types</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>An initialized array of type size_t that is resized to <em>num_types</em> + 1 entries. The indices j of <em>array</em> that contain objects of type k are <em>offsets</em>[k] &lt;= j &lt; <em>offsets</em>[k + 1]. If there are no objects of type k, then <em>offsets</em>[k] = <em>offset</em>[k + 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_types</td><td>The number of possible types of objects in <em>array</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_fn</td><td>Returns the type of an object in the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Arbitrary user data passed to <em>type_fn</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd6536ee67b1b02848dd529ffd1e3fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the array count to zero, but does not free elements. </p>
<p>Not allowed for views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is intended to allow an sc_array to be used as a reusable buffer, where the "high water mark" of the buffer is preserved, so that O(log (max n)) reallocs occur over the life of the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a7be396714f4ea39005cab1bc666666a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_uniq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removed duplicate entries from a sorted array. </p>
<p>This function is not allowed for views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array size will be reduced as necessary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cc4c1933168da0ac3b075df053ceab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_hash_array_insert_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an object into a hash array if it is not contained already. </p>
<p>The object is not copied into the array. Use the return value for that. New objects are guaranteed to be added at the end of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the object. Used for search only. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>If position != NULL, *position is set to the array position of the already contained, or if not present, the new object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL if the object is already contained. Otherwise returns its new address in the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a1743a8aa716313f45e754b05f4066d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_array_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an object is contained in a hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>If position != NULL, *position is set to the array position of the already contained object if found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if object is found, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a287e5cf0f7ea5b4a16e534a19fffa595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_hash_array_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>ha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by a hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ha</td><td>The hash array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa086b8ede8a18ebdcfb690d6bf73e86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a>* sc_hash_array_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#aa6bfc43fa4a8b7626d8095725d4c7cfc">sc_hash_function_t</a>&#160;</td>
          <td class="paramname"><em>hash_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a3b7e4c7164f43ab79e1e9d463c3c8584">sc_equal_function_t</a>&#160;</td>
          <td class="paramname"><em>equal_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_fn</td><td>Function to compute the hash value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equal_fn</td><td>Function to test two objects for equality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf5b81adba0e4c4c3c557dcf7613f36b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_array_rip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__array__t.html">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>rip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the array data from a hash array and destroy everything else. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_array</td><td>The hash array is destroyed after extraction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rip</td><td>Array structure that will be overwritten. All previous array data (if any) will be leaked. The filled array can be freed with sc_array_reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8557bf638bc729901df79c86f05e04c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_array_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__array__t.html">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from the hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_array</td><td>Hash array to truncate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4485f83fdfee14e4a14573f4efe7c108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a hash table. </p>
<p>If the allocator is owned, this runs in O(1), otherwise in O(N). </p>
<dl class="section note"><dt>Note</dt><dd>If allocator was provided in sc_hash_new, it will not be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="accbe548fa780a3d3ce1a719075eb3d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a713a10d24f49429533235754a7a2fa69">sc_hash_foreach_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke a callback for every member of the hash table. </p>
<p>The functions hash_fn and equal_fn are not called by this function. </p>

</div>
</div>
<a class="anchor" id="afef8c7f8057e0f36ea6f1c6f2ab6c571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned sc_hash_function_string </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a hash value from a null-terminated string. </p>
<p>This hash function is NOT cryptographically safe! Use libcrypt then. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Null-terminated string to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed hash value as an unsigned integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a471ac510c147c97b396a980d7cfc6852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_insert_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an object into a hash table if it is not contained already. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to be inserted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found</td><td>If found != NULL, *found is set to the address of the pointer to the already contained, or if not present, the new object. You can assign to **found to override. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if object is added, false if it is already contained. </dd></dl>

</div>
</div>
<a class="anchor" id="ac491f058bd4a47555c203e94db47f37c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an object is contained in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to be looked up. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found</td><td>If found != NULL, *found is set to the address of the pointer to the already contained object if the object is found. You can assign to **found to override. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if object is found, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a61448f834b749daa38248ad391417e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_hash_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by a hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>The hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a79301891a134c0765dd8770cd88545d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__hash__t.html">sc_hash_t</a>* sc_hash_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#aa6bfc43fa4a8b7626d8095725d4c7cfc">sc_hash_function_t</a>&#160;</td>
          <td class="paramname"><em>hash_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a3b7e4c7164f43ab79e1e9d463c3c8584">sc_equal_function_t</a>&#160;</td>
          <td class="paramname"><em>equal_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new hash table. </p>
<p>The number of hash slots is chosen dynamically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_fn</td><td>Function to compute the hash value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equal_fn</td><td>Function to test two objects for equality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed through to the hash function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator for <a class="el" href="structsc__link__t.html" title="The sc_link structure is one link of a linked list. ">sc_link_t</a>, can be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3368ef4a371e8128a96e159ea28c3c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an object from a hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to be removed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found</td><td>If found != NULL, *found is set to the object that is removed if that exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if object is found, false if is not contained. </dd></dl>

</div>
</div>
<a class="anchor" id="a6018b3a4e5c51501d52094335bb85d11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all entries from a hash table in O(N). </p>
<p>If the allocator is owned, it calls sc_hash_unlink and sc_mempool_truncate. Otherwise, it calls sc_list_reset on every hash slot which is slower. </p>

</div>
</div>
<a class="anchor" id="ab2992a0fc01581345b413f460a4b7927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink all hash elements without returning them to the mempool. </p>
<p>If the allocator is not owned, this runs faster than sc_hash_truncate, but is dangerous because of potential memory leaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash</td><td>Hash structure to be unlinked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6fe8987fef58946b5327ea202cfb9c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_unlink_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__hash__t.html">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same effect as unlink and destroy, but in O(1). </p>
<p>This is dangerous because of potential memory leaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Hash structure to be unlinked and destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9d366868c0011ee034b4e1b5d6f701f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a linked list structure in O(N). </p>
<dl class="section note"><dt>Note</dt><dd>If allocator was provided in sc_list_new, it will not be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2345f4f800f46d60d612c6d9545758dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated list structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>List structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>External memory allocator for <a class="el" href="structsc__link__t.html" title="The sc_link structure is one link of a linked list. ">sc_link_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a306aa840346179aaaab47cbd8c4f2e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__link__t.html">sc_link_t</a> *&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element after a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>The predecessor of the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc4ec6b2855dcb3125310f6ad2928ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_list_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_dynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_dynamic</td><td>True if created with sc_list_new, false if initialized with sc_list_init </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a16ed388e36eb3088d911d68f995be3b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__list__t.html">sc_list_t</a>* sc_list_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a linked list structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator for <a class="el" href="structsc__link__t.html" title="The sc_link structure is one link of a linked list. ">sc_link_t</a>, can be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affcaa9043e79854360ab37bdc670e668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_list_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element from the front of the list. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the data of the removed first list element. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf1dfcc941294ac2b6898db6b798938d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsc__link__t.html">sc_link_t</a> *&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element after a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>The predecessor of the element to be removed. If <em>pred</em> == NULL, the first element is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the data of the removed element. </dd></dl>

</div>
</div>
<a class="anchor" id="ab87b22d2b61f04d3c73d93e9218b97c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from a list in O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>List structure to be resetted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling sc_list_init, then any list operations, then sc_list_reset is memory neutral. </dd></dl>

</div>
</div>
<a class="anchor" id="a5934247f1587a5376772ec2d035f812f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__list__t.html">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unliks all list elements without returning them to the mempool. </p>
<p>This runs in O(1) but is dangerous because of potential memory leaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>List structure to be unlinked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54946e5aa0c63bc895bee4756e7a10d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sc_mempool_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a single element. </p>
<p>Elements previously returned to the pool are recycled. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new or recycled element pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a45ecbb2b02cf93632c79c7307f5238ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mempool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a mempool structure. </p>
<p>All elements that are still in use are invalidated. </p>

</div>
</div>
<a class="anchor" id="a963b62dc73a1005533add75ad89308b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_mempool_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a previously allocated element to the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be returned to the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73235130bba53a9ed8b07ddfa27fadae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_mempool_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab416c24d85ffd174f0dd3ad89c4c1163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsc__mempool__t.html">sc_mempool_t</a>* sc_mempool_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new mempool structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one element in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an allocated and initialized memory pool. </dd></dl>

</div>
</div>
<a class="anchor" id="a953f00fc29ceeed5ee0b0629aa36ec7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_recycle_array_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a recycle array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of the objects to be stored in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc40dce6d559ee358c2bb469e64c379d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_recycle_array_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an object into the recycle array. </p>
<p>The object is not copied into the array. Use the return value for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>If position != NULL, *position is set to the array position of the inserted object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new address of the object in the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a788e8444ddf769046c38afc05bfac38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_recycle_array_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an object from the recycle array. </p>
<p>It must be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Index into the array for the object to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the removed object. Will be valid as long as no other function is called on this recycle array. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cade0e4211936ded04e2a2e7df9ca33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_recycle_array_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsc__recycle__array__t.html">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a recycle array. </p>
<p>As with all _reset functions, calling _init, then any array operations, then _reset is memory neutral. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
