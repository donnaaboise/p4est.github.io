<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>p4est: src/p4est_extended.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">p4est
   &#160;<span id="projectnumber">1.0.25-ff1e</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">p4est_extended.h File Reference<div class="ingroups"><a class="el" href="group__p4est.html">p4est</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface routines with extended capabilities.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="p4est_8h_source.html">p4est.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="p4est__iterate_8h_source.html">p4est_iterate.h</a>&gt;</code><br/>
</div>
<p><a href="p4est__extended_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp4est__inspect.html">p4est_inspect_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data pertaining to selecting, inspecting, and profiling algorithms.  <a href="structp4est__inspect.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae1e49029e7ba64500482e3959c150a3d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a> )(<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, <a class="el" href="p4est__base_8h.html#a8e849f705b0d4d1702b8f5102823f48c">p4est_topidx_t</a> which_tree, int num_outgoing, <a class="el" href="structp4est__quadrant__t.html">p4est_quadrant_t</a> *outgoing[], int num_incoming, <a class="el" href="structp4est__quadrant__t.html">p4est_quadrant_t</a> *incoming[])</td></tr>
<tr class="memdesc:ae1e49029e7ba64500482e3959c150a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function prototype to replace one set of quadrants with another.  <a href="#ae1e49029e7ba64500482e3959c150a3d">More...</a><br/></td></tr>
<tr class="separator:ae1e49029e7ba64500482e3959c150a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac11cf572e8ac72c4beb78465f98b63f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#ac11cf572e8ac72c4beb78465f98b63f3">p4est_new_ext</a> (sc_MPI_Comm mpicomm, <a class="el" href="structp4est__connectivity__t.html">p4est_connectivity_t</a> *connectivity, <a class="el" href="p4est__base_8h.html#a9f350ee78755ec6e7d25fb1dca474573">p4est_locidx_t</a> min_quadrants, int min_level, int fill_uniform, size_t data_size, <a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a> init_fn, void *user_pointer)</td></tr>
<tr class="memdesc:ac11cf572e8ac72c4beb78465f98b63f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new forest.  <a href="#ac11cf572e8ac72c4beb78465f98b63f3">More...</a><br/></td></tr>
<tr class="separator:ac11cf572e8ac72c4beb78465f98b63f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad32df9df3630b6bac05e7366a5f1e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#aad32df9df3630b6bac05e7366a5f1e46">p4est_refine_ext</a> (<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, int refine_recursive, int maxlevel, <a class="el" href="p4est_8h.html#a0dd63652a79d723377e436074f18e900">p4est_refine_t</a> <a class="el" href="p4est__step4_8c.html#ab8a4eb8e5c710a5bf8405bc29cd65b77">refine_fn</a>, <a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a> init_fn, <a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:aad32df9df3630b6bac05e7366a5f1e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a forest with a bounded refinement level and a replace option.  <a href="#aad32df9df3630b6bac05e7366a5f1e46">More...</a><br/></td></tr>
<tr class="separator:aad32df9df3630b6bac05e7366a5f1e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06630b99f70cb85c73452640e8b4d54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#a06630b99f70cb85c73452640e8b4d54e">p4est_coarsen_ext</a> (<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, int coarsen_recursive, int callback_orphans, <a class="el" href="p4est_8h.html#a828e892c579d930dca67beb259c94b7e">p4est_coarsen_t</a> coarsen_fn, <a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a> init_fn, <a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:a06630b99f70cb85c73452640e8b4d54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsen a forest.  <a href="#a06630b99f70cb85c73452640e8b4d54e">More...</a><br/></td></tr>
<tr class="separator:a06630b99f70cb85c73452640e8b4d54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666a197be8d6d83c08cc14bfdc8565ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#a666a197be8d6d83c08cc14bfdc8565ed">p4est_balance_ext</a> (<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, <a class="el" href="p4est__connectivity_8h.html#adc5f6166fc408c325589ce3e620552ca">p4est_connect_type_t</a> btype, <a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a> init_fn, <a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:a666a197be8d6d83c08cc14bfdc8565ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">2:1 balance the size differences of neighboring elements in a forest.  <a href="#a666a197be8d6d83c08cc14bfdc8565ed">More...</a><br/></td></tr>
<tr class="separator:a666a197be8d6d83c08cc14bfdc8565ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055cdb88a4d5bc419295d2bf2560b02f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a055cdb88a4d5bc419295d2bf2560b02f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>p4est_balance_subtree_ext</b> (<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, <a class="el" href="p4est__connectivity_8h.html#adc5f6166fc408c325589ce3e620552ca">p4est_connect_type_t</a> btype, <a class="el" href="p4est__base_8h.html#a8e849f705b0d4d1702b8f5102823f48c">p4est_topidx_t</a> which_tree, <a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a> init_fn, <a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a> replace_fn)</td></tr>
<tr class="separator:a055cdb88a4d5bc419295d2bf2560b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124f2669c375fa66dc746be591ca2404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="p4est__base_8h.html#af4d787f9b2520af0cfe9a10b89235749">p4est_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#a124f2669c375fa66dc746be591ca2404">p4est_partition_ext</a> (<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, int partition_for_coarsening, <a class="el" href="p4est_8h.html#ab5b13e2b7ed3829a87838b346dce3d9d">p4est_weight_t</a> weight_fn)</td></tr>
<tr class="memdesc:a124f2669c375fa66dc746be591ca2404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartition the forest.  <a href="#a124f2669c375fa66dc746be591ca2404">More...</a><br/></td></tr>
<tr class="separator:a124f2669c375fa66dc746be591ca2404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae612311d1e0e5531904d638f1595c3c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#ae612311d1e0e5531904d638f1595c3c8">p4est_iterate_ext</a> (<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, <a class="el" href="structp4est__ghost__t.html">p4est_ghost_t</a> *ghost_layer, void *user_data, <a class="el" href="p4est__iterate_8h.html#acdcb671a70754c7fefa0707149ba026f">p4est_iter_volume_t</a> iter_volume, <a class="el" href="p4est__iterate_8h.html#acd993a6072d4b322388db4ff8f64b0ba">p4est_iter_face_t</a> iter_face, <a class="el" href="p4est__iterate_8h.html#a117266b72f106c58c1da783afa318b47">p4est_iter_corner_t</a> iter_corner, int remote)</td></tr>
<tr class="memdesc:ae612311d1e0e5531904d638f1595c3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">p4est_iterate_ext adds the option <em>remote:</em> if this is false, then it is the same as p4est_iterate; if this is true, then corner callbacks are also called on corners for hanging faces touched by local quadrants.  <a href="#ae612311d1e0e5531904d638f1595c3c8">More...</a><br/></td></tr>
<tr class="separator:ae612311d1e0e5531904d638f1595c3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c85e7fdf9af1af4d5423b6977b9370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#ae1c85e7fdf9af1af4d5423b6977b9370">p4est_save_ext</a> (const char *filename, <a class="el" href="structp4est__t.html">p4est_t</a> *p4est, int save_data, int save_partition)</td></tr>
<tr class="memdesc:ae1c85e7fdf9af1af4d5423b6977b9370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the complete connectivity/p4est data to disk.  <a href="#ae1c85e7fdf9af1af4d5423b6977b9370">More...</a><br/></td></tr>
<tr class="separator:ae1c85e7fdf9af1af4d5423b6977b9370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4827c655f56db1da612a07546111c505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#a4827c655f56db1da612a07546111c505">p4est_load_ext</a> (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, <a class="el" href="structp4est__connectivity__t.html">p4est_connectivity_t</a> **connectivity)</td></tr>
<tr class="memdesc:a4827c655f56db1da612a07546111c505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the complete connectivity/p4est structure from disk.  <a href="#a4827c655f56db1da612a07546111c505">More...</a><br/></td></tr>
<tr class="separator:a4827c655f56db1da612a07546111c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9977106835629eb97c84ba2b7c6b05a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9977106835629eb97c84ba2b7c6b05a"></a>
<a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p4est__extended_8h.html#af9977106835629eb97c84ba2b7c6b05a">p4est_source_ext</a> (sc_io_source_t *src, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, <a class="el" href="structp4est__connectivity__t.html">p4est_connectivity_t</a> **connectivity)</td></tr>
<tr class="memdesc:af9977106835629eb97c84ba2b7c6b05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as p4est_load_ext, but reading the connectivity/p4est from an open sc_io_source_t stream. <br/></td></tr>
<tr class="separator:af9977106835629eb97c84ba2b7c6b05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface routines with extended capabilities. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ae1e49029e7ba64500482e3959c150a3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* p4est_replace_t)(<a class="el" href="structp4est__t.html">p4est_t</a> *p4est, <a class="el" href="p4est__base_8h.html#a8e849f705b0d4d1702b8f5102823f48c">p4est_topidx_t</a> which_tree, int num_outgoing, <a class="el" href="structp4est__quadrant__t.html">p4est_quadrant_t</a> *outgoing[], int num_incoming, <a class="el" href="structp4est__quadrant__t.html">p4est_quadrant_t</a> *incoming[])</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function prototype to replace one set of quadrants with another. </p>
<p>This is used by extended routines when the quadrants of an existing, valid p4est are changed. The callback allows the user to make changes to newly initialized quadrants before the quadrants that they replace are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_outgoing</td><td>The number of outgoing quadrants. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outgoing</td><td>The outgoing quadrants: after the callback, the user_data, if <em>p4est-&gt;data_size</em> is nonzero, will be destroyed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_incoming</td><td>The number of incoming quadrants. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">incoming</td><td>The incoming quadrants: prior to the callback, the user_data, if <em>p4est-&gt;data_size</em> is nonzero, is allocated, and the p4est_init_t callback, if it has been provided, will be called.</td></tr>
  </table>
  </dd>
</dl>
<p>If the mesh is being refined, num_outgoing will be 1 and num_incoming will be 4, and vice versa if the mesh is being coarsened. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a666a197be8d6d83c08cc14bfdc8565ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p4est_balance_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td>
          <td class="paramname"><em>p4est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__connectivity_8h.html#adc5f6166fc408c325589ce3e620552ca">p4est_connect_type_t</a>&#160;</td>
          <td class="paramname"><em>btype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2:1 balance the size differences of neighboring elements in a forest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p4est</td><td>The p4est to be worked on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">btype</td><td>Balance type (face or corner/full). Corner balance is almost never required when discretizing a PDE; just causes smoother mesh grading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data which is already allocated automatically. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06630b99f70cb85c73452640e8b4d54e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p4est_coarsen_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td>
          <td class="paramname"><em>p4est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarsen_recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callback_orphans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est_8h.html#a828e892c579d930dca67beb259c94b7e">p4est_coarsen_t</a>&#160;</td>
          <td class="paramname"><em>coarsen_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coarsen a forest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p4est</td><td>The forest is changed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_recursive</td><td>Boolean to decide on recursive coarsening. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_orphans</td><td>Boolean to enable calling coarsen_fn even on non-families. In this case, the second quadrant pointer in the argument list of the callback is NULL, subsequent pointers are undefined, and the return value is ignored. If coarsen_recursive is true, it is possible that a quadrant is called once or more as an orphan and eventually becomes part of a family. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_fn</td><td>Callback function that returns true if a family of quadrants shall be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data which is already allocated automatically. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae612311d1e0e5531904d638f1595c3c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p4est_iterate_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td>
          <td class="paramname"><em>p4est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structp4est__ghost__t.html">p4est_ghost_t</a> *&#160;</td>
          <td class="paramname"><em>ghost_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__iterate_8h.html#acdcb671a70754c7fefa0707149ba026f">p4est_iter_volume_t</a>&#160;</td>
          <td class="paramname"><em>iter_volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__iterate_8h.html#acd993a6072d4b322388db4ff8f64b0ba">p4est_iter_face_t</a>&#160;</td>
          <td class="paramname"><em>iter_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__iterate_8h.html#a117266b72f106c58c1da783afa318b47">p4est_iter_corner_t</a>&#160;</td>
          <td class="paramname"><em>iter_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remote</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>p4est_iterate_ext adds the option <em>remote:</em> if this is false, then it is the same as p4est_iterate; if this is true, then corner callbacks are also called on corners for hanging faces touched by local quadrants. </p>
<p>initialize arrays that keep track of where we are in the search</p>
<p>we have to loop over all trees and not just local trees because of the ghost layer </p>

</div>
</div>
<a class="anchor" id="a4827c655f56db1da612a07546111c505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structp4est__t.html">p4est_t</a>* p4est_load_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>load_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>autopartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>broadcasthead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structp4est__connectivity__t.html">p4est_connectivity_t</a> **&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the complete connectivity/p4est structure from disk. </p>
<p>It is possible to load the file with a different number of processors than has been used to write it. The partition will then be uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>A valid MPI communicator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data for each quadrant which can be zero. Then user_data_pool is set to NULL. If data_size is zero, load_data is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_data</td><td>If true, the element data is loaded. This is only permitted if the saved data size matches. If false, the stored data size is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autopartition</td><td>Ignore saved partition and make it uniform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">broadcasthead</td><td>Have only rank 0 read headers and bcast them. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_pointer</td><td>Assign to the user_pointer member of the p4est before init_fn is called the first time. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">connectivity</td><td>Connectivity must be destroyed separately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a valid forest structure. A pointer to a valid connectivity structure is returned through the last argument. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Aborts on file errors or invalid file contents. </dd></dl>

</div>
</div>
<a class="anchor" id="ac11cf572e8ac72c4beb78465f98b63f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structp4est__t.html">p4est_t</a>* p4est_new_ext </td>
          <td>(</td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structp4est__connectivity__t.html">p4est_connectivity_t</a> *&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__base_8h.html#a9f350ee78755ec6e7d25fb1dca474573">p4est_locidx_t</a>&#160;</td>
          <td class="paramname"><em>min_quadrants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_uniform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new forest. </p>
<p>This is a more general form of p4est_new. See the documentation of p4est_new for basic usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_quadrants</td><td>Minimum initial quadrants per processor. Makes the refinement pattern mpisize-specific. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_level</td><td>The forest is refined at least to this level. May be negative or 0, then it has no effect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_uniform</td><td>If true, fill the forest with a uniform mesh instead of the coarsest possible one. The latter is partition-specific so that is usually not a good idea. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a124f2669c375fa66dc746be591ca2404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="p4est__base_8h.html#af4d787f9b2520af0cfe9a10b89235749">p4est_gloidx_t</a> p4est_partition_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td>
          <td class="paramname"><em>p4est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partition_for_coarsening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est_8h.html#ab5b13e2b7ed3829a87838b346dce3d9d">p4est_weight_t</a>&#160;</td>
          <td class="paramname"><em>weight_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repartition the forest. </p>
<p>The forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p4est</td><td>The forest that will be partitioned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partition_for_coarsening</td><td>If true, the partition is modified to allow one level of coarsening. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight_fn</td><td>A weighting function or NULL for uniform partitioning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The global number of shipped quadrants </dd></dl>

</div>
</div>
<a class="anchor" id="aad32df9df3630b6bac05e7366a5f1e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p4est_refine_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td>
          <td class="paramname"><em>p4est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est_8h.html#a0dd63652a79d723377e436074f18e900">p4est_refine_t</a>&#160;</td>
          <td class="paramname"><em>refine_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est_8h.html#afa4d681a64c992efa907dfd589eba1ec">p4est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__extended_8h.html#ae1e49029e7ba64500482e3959c150a3d">p4est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine a forest with a bounded refinement level and a replace option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p4est</td><td>The forest is changed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refine_recursive</td><td>Boolean to decide on recursive refinement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxlevel</td><td>Maximum allowed refinement level (inclusive). If this is negative the level is restricted only by the compile-time constant QMAXLEVEL in <a class="el" href="p4est_8h.html" title="The top-level 2D p4est interface. ">p4est.h</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refine_fn</td><td>Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn or replace_fn gets called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data for newly created quadrants, which is guaranteed to be allocated. This function pointer may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace; may be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1c85e7fdf9af1af4d5423b6977b9370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p4est_save_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structp4est__t.html">p4est_t</a> *&#160;</td>
          <td class="paramname"><em>p4est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>save_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>save_partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the complete connectivity/p4est data to disk. </p>
<p>This is a collective operation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p4est_load_ext for information on the autopartition parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p4est</td><td>Valid forest structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save_data</td><td>If true, the element data is saved. Otherwise, a data size of 0 is saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save_partition</td><td>If false, save file as if 1 core was used. If true, save core count and partition. Advantage: Partition can be recovered on loading with same mpisize and autopartition false. Disadvantage: Makes the file depend on mpisize. Either way the file can be loaded with autopartition true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Aborts on file errors. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
